<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Keepalived+Haproxy高可用怎么玩]]></title>
    <url>%2F2019%2F09%2F21%2Fhaproxy%2F</url>
    <content type="text"><![CDATA[一、前言1.1 Haproxy功能特性 HAProxy提供高可用性、负载均衡以及基于TCP和HTTP应用的代理，支持虚拟主机，它是免费、快速并且可靠的一种解决方案。 HAProxy运行在当前的硬件上，完全可以支持数以万计的并发连接。并且它的运行模式使得它可以很简单安全的整合进您当前的架构中， 同时可以保护你的web服务器不被暴露到网络上。 Haproxy四层负载。将网络流量负载平衡到多个服务器的最简单方法是使用第4层（传输层）负载平衡。以这种方式进行负载均衡将根据IP范围和端口转发用户流量。(常用作四层，这里就着重介绍四层负载均衡) 1.2 准备工具 keepalived（yum安装） haproxy-1.9.8-0.el7.x86_64.rpm(官网下载rpm包) 两台Centos7服务器:192.168.10.1、192.168.10.2(两台主从高可用) VIP虚拟IP: 172.16.20.20(keepalived高可用漂移) 二、Haproxy安装配置2.1 安装依赖 SSH登陆第一台服务器192.168.10.1 新增www用户，用于启动haproxy服务 ssh 192.168.10.1 yum install gcc gcc-c++ pcre pcre-devel zlib zlib-devel openssl openssl-devel lua-devel GeoIP GeoIP-devel GeoIP-data systemd-devel -y useradd www -s /sbin/nologin 2.2 安装haproxy 拷贝haproxy-1.9.8-0.el7.x86_64.rpm到/root/目录下 rpm -ivh haproxy-1.9.8-0.el7.x86_64.rpm 2.3 配置haproxy.cfg 进入主目录/etc/haproxy/ vim haproxy.cfg global log 127.0.0.1 local0 log 127.0.0.1 local1 notice //开启日志用的 user www group www maxconn 100000 defaults mode tcp retries 3 option tcplog option redispatch option abortonclose #option dontlognull option log-health-checks //开启后端server健康检查日志输出 option httpclose balance roundrobin //后端server流量轮询 maxconn 100000 timeout connect 3000 timeout client 3600000 timeout server 3600000 listen status //开启haproxy后台管理页面 bind :1080 mode http log global stats enable stats refresh 30s stats uri /admin stats realm HAProxy\ Stats stats hide-version stats auth root:123456 //配置账户密码 stats admin if TRUE ##################### 配置两组四层服务案例 ##################### frontend MySQL //定义这个服务的名字为MySQL bind 172.16.20.20:3306 //监听VIP的3306端口 log global acl ACL_DB-MYSQL-1 dst 172.16.20.20 use_backend DB-MYSQL-1 if ACL_DB-MYSQL-1 frontend redis //定义这个服务的名字为redis bind 172.16.20.20:10333 //监听的VIP的10333端口 log global default_backend redis backend DB-MYSQL-1 log 127.0.0.1 local0 notice //这行必须加上，否则日志不输出健康检查状态 server 192.168.100.20 192.168.100.21:3306 check inter 1000 rise 3 fall 3 server 192.168.100.21 192.168.100.21:3306 check inter 1000 rise 3 fall 3 backup //状态为备机，只要上面一个服务器挂了，健康检查3秒之后下线，然后备机就顶上了 backend redis log 127.0.0.1 local0 notice server 192.168.100.22 192.168.100.22:6379 check inter 1000 rise 3 fall 3 2.4 启动服务#验证配置有没有语法错误 /etc/haproxy/sbin/haproxy -c -f /etc/haproxy/haproxy.cfg Configuration file is valid //出现这个表示配置文件没问题 systemctl start haproxy //启动 systemctl reload haproxy //重新载入配置 三、Keepalived安装配置3.1 yum安装yum install keepalived -y 3.2 keepalived配置文件 keepalived 采用的是非抢占模式（建议） vim /etc/keepalived/keepalived.conf ! Configuration File for keepalived global_defs { } #这是第一个脚本，检测haproxy进程是否存在，不存在则结束keepalived,VIP漂移到备用从服务器，实现高可用 vrrp_script check_haproxy { script &quot;/etc/keepalived/check_haproxy.sh&quot; //脚本存放路径 } vrrp_instance VI_1 { state BACKUP //都定义backup为非抢占模式 nopreempt interface eth0 virtual_router_id 100 priority 100 //主机器权重为100，从机器要比这小，可以配置90 advert_int 1 unicast_src_ip 192.168.10.1 //本机主IP unicast_peer { 192.168.10.2 //对端从IP,在从机器上，这两个主从IP是反过来的 } authentication { auth_type PASS auth_pass haproxy //这里可以自定义一个字符串，但两边要保证一致 } virtual_ipaddress { 172.16.20.20/16 //虚拟IP配置在这里 } #以下是另外一个脚本，在日志里面打印出keepalived服务状态， notify_master &quot;/etc/keepalived/notify_action.sh MASTER&quot; notify_backup &quot;/etc/keepalived/notify_action.sh BACKUP&quot; notify_fault &quot;/etc/keepalived/notify_action.sh FAULT&quot; notify_stop &quot;/etc/keepalived/notify_action.sh STOP&quot; garp_master_delay 1 garp_master_refresh 5 track_script { check_haproxy //调用上面定义的脚本 } } 3.3 自定义脚本3.3.1 haproxy状态检测脚本 此脚本的目的是检测haproxy状态，当haproxy主程序挂掉之后，自动杀掉keepalived程序，把vip漂移到备用从服务器，从而实现高可用 vim /etc/keepalived/check_haproxy.sh #!/bin/bash #检测nginx进程不存在了，尝试启动，发现启动不了则切换到备用机器 A=`ps -C haproxy --no-header |wc -l` if [ `ps -C haproxy --no-header |wc -l` -eq 0 ];then systemctl stop keepalived fi 3.3.2 Keepalived日志输出状态 这个脚本可选，属于我自己自定义的，没有需要可以跳过，并去掉keepalived配置文件里的引用此脚本部分 此脚本目的就是当keepalived状态发生改变，比如服务停止、启动把定义的状态输出到日志上，以便后续排错 vim /etc/keepalived/notify_action.sh #!/bin/bash #/etc/keepalived/notify_action.sh log_file=/var/log/keepalived.log log_write() { echo &quot;[`date &#39;+%Y-%m-%d %T&#39;`] $1&quot; &gt;&gt; $log_file } [ ! -d /var/keepalived/ ] &amp;&amp; mkdir -p /var/keepalived/ case &quot;$1&quot; in &quot;MASTER&quot; ) echo -n &quot;$1&quot; &gt; /var/keepalived/state log_write &quot; notify_master&quot; echo -n &quot;0&quot; &gt; /var/keepalived/vip_check_failed_count ;; &quot;BACKUP&quot; ) echo -n &quot;$1&quot; &gt; /var/keepalived/state log_write &quot; notify_backup&quot; ;; &quot;FAULT&quot; ) echo -n &quot;$1&quot; &gt; /var/keepalived/state log_write &quot; notify_fault&quot; ;; &quot;STOP&quot; ) echo -n &quot;$1&quot; &gt; /var/keepalived/state log_write &quot; notify_stop&quot; ;; *) log_write &quot;notify_action.sh: STATE ERROR!!!&quot; ;; esac 3.3.3 脚本添加权限chmod +x check_haproxy.sh notify_action.sh 3.4 启动keepalived服务 启动服务后，可以通过ip a查看本机ip是否多了一个虚拟ip：172.16.20.20 绑定在上面，这样就算成功了 systemctl start keepalived //启动 systemctl reload keepalived //变更配置后，一般用这个命令重新加载 3.4 备用从服务器操作注意事项 把上面haproxy安装配置和keepalived安装配置照着完全做一份，操作步骤一样，可以安装好把主服务器上配置文件拷贝过去 唯一的区别就是从服务器的keepalived配置文件有稍微区别需要注意,我直接附上配置 vim /etc/keepalived/keepalived.conf ! Configuration File for keepalived global_defs { } #这是第一个脚本，检测haproxy进程是否存在，不存在则结束keepalived,VIP漂移到备用从服务器，实现高可用 vrrp_script check_haproxy { script &quot;/etc/keepalived/check_haproxy.sh&quot; //脚本存放路径 } vrrp_instance VI_1 { state BACKUP //都定义backup为非抢占模式 nopreempt interface eth0 virtual_router_id 100 //此ID号保持一致，同一个局域网最好不要有重复的 priority 90 //主机器权重为100，这里设置90，一定要比主的小 advert_int 1 unicast_src_ip 192.168.10.2 //本机主IP unicast_peer { 192.168.10.1 //对端从IP } authentication { auth_type PASS auth_pass haproxy //这里可以自定义一个字符串，但两边要保证一致 } virtual_ipaddress { 172.16.20.20/16 //虚拟IP配置在这里 } #以下是另外一个脚本，在日志里面打印出keepalived服务状态， notify_master &quot;/etc/keepalived/notify_action.sh MASTER&quot; notify_backup &quot;/etc/keepalived/notify_action.sh BACKUP&quot; notify_fault &quot;/etc/keepalived/notify_action.sh FAULT&quot; notify_stop &quot;/etc/keepalived/notify_action.sh STOP&quot; garp_master_delay 1 garp_master_refresh 5 track_script { check_haproxy //调用上面定义的脚本 } } 3.5 验证配置 杀掉主服务器上的haproxy程序，看看keepalived是否也紧跟着同时被杀掉了，虚ip被漂移到备用服务器上了 连接虚拟ip的6379端口以及3306端口，看能否正常转发到后端服务器上 访问haproxy管理页面：http://172.16.20.20:1080/admin (root/123456) 四、日志开启及切割 keepalivedi日志开启，存储到 /var/log/keepalived.log haproxy开启日志，存储到/var/log/haproxy/haproxy.log 每日0点切割日志压缩保存 4.1 开启keepalived日志 vim /etc/sysconfig/keepalived KEEPALIVED_OPTIONS=&quot;-D -S 0 -d&quot; vim /etc/rsyslog.conf local0.* /var/log/keepalived.log service rsyslog restart 4.1 开启Haproxy日志 vim /etc/rsyslog.conf vim /etc/rsyslog.conf $ModLoad imudp $UDPServerRun 514 local0.* /var/log/haproxy/haproxy.log vim /etc/rsyslog.conf local0.* /var/log/keepalived.log service rsyslog restart 4.3 切割Haproxy日志 如果不设定时间，切割默认是凌晨3点多执行 vim /etc/logrotate.d/logrotate_haproxy /var/log/haproxy/haproxy.log { su root root daily missingok rotate 15 //默认我设置的是保留15天 compress notifempty create 644 root root dateext sharedscripts postrotate systemctl restart rsyslog endscript } 测试切割：logrotate -d /etc/logrotate.d/logrotate_haproxy 强制执行切割：/usr/sbin/logrotate -f /etc/logrotate.d/logrotate_haproxy 五、额外补充5.1 Haproxy管理页面参数介绍haproxy页面参数解释： 页面详细参数解释 Queue Cur: current queued requests //当前的队列请求数量 Max：max queued requests //最大的队列请求数量 Limit： //队列限制数量 Session rate(每秒的连接回话)列表： scur: current sessions //每秒的当前回话的限制数量 smax: max sessions //每秒的新的最大的回话量 slim: sessions limit //每秒的新回话的限制数量 Sessions Total: //总共回话量 Cur: //当前的回话 Max: //最大回话 Limit: //回话限制 Lbtot: total number of times a server was selected //选中一台服务器所用的总时间 Bytes In： //网络的字节数输入总量 Out： //网络的字节数输出总量 Denied Req: denied requests//拒绝请求量 Resp：denied responses //拒绝回应 Errors Req：request errors //错误请求 Conn：connection errors //错误的连接 Resp: response errors (among which srv_abrt) ///错误的回应 Warnings Retr: retries (warning) //重新尝试 Redis：redispatches (warning) //再次发送 Server列表： Status:状态，包括up(后端机活动)和down(后端机挂掉)两种状态 LastChk: 持续检查后端服务器的时间 Wght: (weight) : 权重 Act: server is active (server), number of active servers (backend) //活动链接数量 Bck: server is backup (server), number of backup servers (backend) //backup：备份的服务器数量 Down： //后端服务器连接后都是down的数量 Downtime: downtime: total downtime (in seconds) //总的downtime 时间 Throttle: warm up status //设备变热状态 1.3 Haproxy配置文件参数介绍haproxy 配置中分成五部分内容，分别如下： global： 设置全局配置参数，属于进程的配置，通常是和操作系统相关。 defaults：配置默认参数，这些参数可以被用到frontend，backend，Listen组件； frontend：接收请求的前端虚拟节点，Frontend可以更加规则直接指定具体使用后端的backend； backend：后端服务集群的配置，是真实服务器，一个Backend对应一个或者多个实体服务器； Listen ：frontend和backend的组合体。 ———————————————— 版权声明：本文为CSDN博主「Resines」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/genglei1022/article/details/83374188 global # 全局参数的设置 log 127.0.0.1 local0 info # log语法：log &lt;address_1&gt;[max_level_1] # 全局的日志配置，使用log关键字，指定使用127.0.0.1上的syslog服务中的local0日志设备，记录日志等级为info的日志 user haproxy group haproxy # 设置运行haproxy的用户和组，也可使用uid，gid关键字替代之 daemon # 以守护进程的方式运行 nbproc 16 # 设置haproxy启动时的进程数，根据官方文档的解释，我将其理解为：该值的设置应该和服务器的CPU核心数一致，即常见的2颗8核心CPU的服务器，即共有16核心，则可以将其值设置为：&lt;=16 ，创建多个进程数，可以减少每个进程的任务队列，但是过多的进程数也可能会导致进程的崩溃。这里我设置为16 maxconn 4096 # 定义每个haproxy进程的最大连接数 ，由于每个连接包括一个客户端和一个服务器端，所以单个进程的TCP会话最大数目将是该值的两倍。 #ulimit -n 65536 # 设置最大打开的文件描述符数，在1.4的官方文档中提示，该值会自动计算，所以不建议进行设置 pidfile /var/run/haproxy.pid # 定义haproxy的pid defaults # 默认部分的定义 mode http # mode语法：mode {http|tcp|health} 。http是七层模式，tcp是四层模式，health是健康检测，返回OK log 127.0.0.1 local3 err # 使用127.0.0.1上的syslog服务的local3设备记录错误信息 retries 3 # 定义连接后端服务器的失败重连次数，连接失败次数超过此值后将会将对应后端服务器标记为不可用 option httplog # 启用日志记录HTTP请求，默认haproxy日志记录是不记录HTTP请求的，只记录“时间[Jan 5 13:23:46] 日志服务器[127.0.0.1] 实例名已经pid[haproxy[25218]] 信息[Proxy http_80_in stopped.]”，日志格式很简单。 option redispatch # 当使用了cookie时，haproxy将会将其请求的后端服务器的serverID插入到cookie中，以保证会话的SESSION持久性；而此时，如果后端的服务器宕掉了，但是客户端的cookie是不会刷新的，如果设置此参数，将会将客户的请求强制定向到另外一个后端server上，以保证服务的正常。 option abortonclose # 当服务器负载很高的时候，自动结束掉当前队列处理比较久的链接 option dontlognull # 启用该项，日志中将不会记录空连接。所谓空连接就是在上游的负载均衡器或者监控系统为了探测该服务是否存活可用时，需要定期的连接或者获取某一固定的组件或页面，或者探测扫描端口是否在监听或开放等动作被称为空连接；官方文档中标注，如果该服务上游没有其他的负载均衡器的话，建议不要使用该参数，因为互联网上的恶意扫描或其他动作就不会被记录下来 option httpclose # 这个参数我是这样理解的：使用该参数，每处理完一个request时，haproxy都会去检查http头中的Connection的值，如果该值不是close，haproxy将会将其删除，如果该值为空将会添加为：Connection: close。使每个客户端和服务器端在完成一次传输后都会主动关闭TCP连接。与该参数类似的另外一个参数是“option forceclose”，该参数的作用是强制关闭对外的服务通道，因为有的服务器端收到Connection: close时，也不会自动关闭TCP连接，如果客户端也不关闭，连接就会一直处于打开，直到超时。 contimeout 5000 # 设置成功连接到一台服务器的最长等待时间，默认单位是毫秒，新版本的haproxy使用timeout connect替代，该参数向后兼容 clitimeout 3000 # 设置连接客户端发送数据时的成功连接最长等待时间，默认单位是毫秒，新版本haproxy使用timeout client替代。该参数向后兼容 srvtimeout 3000 # 设置服务器端回应客户度数据发送的最长等待时间，默认单位是毫秒，新版本haproxy使用timeout server替代。该参数向后兼容 listen status # 定义一个名为status的部分 bind 0.0.0.0:1080 # 定义监听的套接字 mode http # 定义为HTTP模式 log global # 继承global中log的定义 stats refresh 30s # stats是haproxy的一个统计页面的套接字，该参数设置统计页面的刷新间隔为30s stats uri /admin?stats # 设置统计页面的uri为/admin?stats stats realm Private lands # 设置统计页面认证时的提示内容 stats auth admin:password # 设置统计页面认证的用户和密码，如果要设置多个，另起一行写入即可 stats hide-version # 隐藏统计页面上的haproxy版本信息 frontend http_80_in # 定义一个名为http_80_in的前端部分 bind 0.0.0.0:80 # http_80_in定义前端部分监听的套接字 mode http # 定义为HTTP模式 log global # 继承global中log的定义 option forwardfor # 启用X-Forwarded-For，在requests头部插入客户端IP发送给后端的server，使后端server获取到客户端的真实IP acl static_down nbsrv(static_server) lt 1 # 定义一个名叫static_down的acl，当backend static_sever中存活机器数小于1时会被匹配到 acl php_web url_reg /*.php$ #acl php_web path_end .php # 定义一个名叫php_web的acl，当请求的url末尾是以.php结尾的，将会被匹配到，上面两种写法任选其一 acl static_web url_reg /*.(css|jpg|png|jpeg|js|gif)$ #acl static_web path_end .gif .png .jpg .css .js .jpeg # 定义一个名叫static_web的acl，当请求的url末尾是以.css、.jpg、.png、.jpeg、.js、.gif结尾的，将会被匹配到，上面两种写法任选其一 use_backend php_server if static_down # 如果满足策略static_down时，就将请求交予backend php_server use_backend php_server if php_web # 如果满足策略php_web时，就将请求交予backend php_server use_backend static_server if static_web # 如果满足策略static_web时，就将请求交予backend static_server backend php_server #定义一个名为php_server的后端部分 mode http # 设置为http模式 balance source # 设置haproxy的调度算法为源地址hash cookie SERVERID # 允许向cookie插入SERVERID，每台服务器的SERVERID可在下面使用cookie关键字定义 option httpchk GET /test/index.php # 开启对后端服务器的健康检测，通过GET /test/index.php来判断后端服务器的健康情况 server php_server_1 10.12.25.68:80 cookie 1 check inter 2000 rise 3 fall 3 weight 2 server php_server_2 10.12.25.72:80 cookie 2 check inter 2000 rise 3 fall 3 weight 1 server php_server_bak 10.12.25.79:80 cookie 3 check inter 1500 rise 3 fall 3 backup # server语法：server [:port] [param*] # 使用server关键字来设置后端服务器；为后端服务器所设置的内部名称[php_server_1]，该名称将会呈现在日志或警报中、后端服务器的IP地址，支持端口映射[10.12.25.68:80]、指定该服务器的SERVERID为1[cookie 1]、接受健康监测[check]、监测的间隔时长，单位毫秒[inter 2000]、监测正常多少次后被认为后端服务器是可用的[rise 3]、监测失败多少次后被认为后端服务器是不可用的[fall 3]、分发的权重[weight 2]、最后为备份用的后端服务器，当正常的服务器全部都宕机后，才会启用备份服务器[backup] backend static_server mode http option httpchk GET /test/index.html]]></content>
      <categories>
        <category>负载均衡</category>
      </categories>
      <tags>
        <tag>haproxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tengine安装]]></title>
    <url>%2F2019%2F09%2F16%2Ftenine-install%2F</url>
    <content type="text"><![CDATA[一、前言 Tengine是由淘宝网发起的Web服务器项目。它在Nginx的基础上，针对大访问量网站的需求，添加了很多高级功能和特性。 我个人很欣赏的一个功能，它有一个很好的dyups模块，可以动态上下线upstream中的后端机器，而不用重启服务 二、开始安装2.1 安装依赖yum install gcc gcc-c++ pcre pcre-devel zlib zlib-devel openssl openssl-devel lua-devel GeoIP GeoIP-devel GeoIP-data systemd-devel -y 2.2 下载解压 从官网 http://tengine.taobao.org/下载tengine-2.2.3.tar.gz 解压到/root/目录下 tar zxvf tengine-2.2.3.tar.gz2.3 编译安装cd tengine-2.2.3 ./configure --prefix=/usr/local/nginx --with-http_lua_module --with-http_dyups_module --with-http_dyups_lua_api --with-threads --with-http_v2_module --with-http_geoip_module --with-http_ssl_module --with-http_secure_link_module --add-module=/root/ngx_http_substitutions_filter_module --with-force-exit --with-http_realip_module 2.4 服务启动ln -s /usr/local/nginx/sbin/nginx /sbin/nginx nginx -t nginx -s reload]]></content>
      <categories>
        <category>负载均衡</category>
      </categories>
      <tags>
        <tag>tengine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tengine配置防百度爬虫]]></title>
    <url>%2F2019%2F09%2F03%2FAnti-reptile%2F</url>
    <content type="text"><![CDATA[发现此xxx.xxxx.cn一直被下面这个ua爬取:Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html) tengine配置if判断ua，挡掉这个爬虫 1.配置confvim xxx.xxxx.cn #添加以下配置 if ($http_user_agent ~ &quot;Mozilla/5.0\ \(compatible;\ Baiduspider/2.0;\ \+http://www.baidu.com/search/spider.html&quot;) { return 403; } if ($http_user_agent ~* ^Baiduspider) { return 403; } 2.测试nginx -t 和 nginx -s reload 3.额外补充方法：3.1 新建user-agent_deny.conf配置文件#禁止Scrapy等工具的抓取 if ($http_user_agent ~* (Scrapy|Curl|HttpClient)) { return 403; } #禁止指定UA及UA为空的访问 if ($http_user_agent ~* &quot;FeedDemon|Indy Library|YandexBot|Alexa Toolbar|AskTbFXTV|AhrefsBot|CrawlDaddy|CoolpadWebkit|Java|Feedly|UniversalFeedParser|ApacheBench|Microsoft URL Control|Swiftbot|ZmEu|oBot|jaunty|Python-urllib|lightDeckReports Bot|YYSpider|DigExt|HttpClient|MJ12bot|heritrix|EasouSpider|Ezooms|^$&quot; ) { return 403; } #禁止非GET|HEAD|POST方式的抓取 if ($request_method !~ ^(GET|HEAD|POST)$) { return 403; } #然后直接reload即可 3.2 添加default_server; server { listen 81 default_server; server_name _; return 403; } default_server：nginx的虚拟主机是通过HTTP请求中的Host值来找到对应的虚拟主机配置 对于未绑定的域名指向你的服务器时，匹配不到你配置的虚拟主机域名后，会默认使用这个虚拟主机，然后直接返回403（状态码，可以自己定义，且返回内容可以通过error_page、echo或是lua等等）]]></content>
      <categories>
        <category>负载均衡</category>
      </categories>
      <tags>
        <tag>tengine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cisco switch配置管理]]></title>
    <url>%2F2019%2F07%2F25%2Fcisco-switch%2F</url>
    <content type="text"><![CDATA[一、准备1.1 准备工具当拿到一台新的思科交换机，开始动手配置，目标实现远程登陆和管理 硬件：笔记本、Console配置线、交换机Cisco3560一台 软件：SecureCRT 1.2 连接交换机首先在“计算机”----“管理”----“设备管理器”中查看com口的编号(本例为com3口) 然后打开SecureCRT软件，添加连接： 协议：Serial 端口：com3 波特率：9600成功连接之后开始进行配置 二、交换机配置管理2.1、配置登录用户、密码及SSH连接Switch#configure terminal //进入配置模式 Switch(config)# ip domain-name loverbook.com //在生成加密密码时需要用到用户名和域名 Switch(config)#crypto key generate rsa //生成加密密钥 The name for the keys will be: Switch.loverbook.com Choose the size of the key modulus in the range of 360 to 2048 for your General Purpose Keys. Choosing a key modulus greater than 512 may takea few minutes. How many bits in the modulus [512]: 1024 //生成一个rsa算法的密钥，密钥为1024位 % Generating 1024 bit RSA keys, keys will be non-exportable...[OK] Switch(config)#line vty 0 15 //进入vty模式 Switch(config-line)#transport input none //取消任何登录方式 Switch(config-line)#transport input ssh //只允许ssh登录 Switch(config-line)#exit //退出vty Switch(config)#aaa new-mode //开启AAA认证 Switch(config)#aaa authentication login default local //本地认证 Switch(config)# username admin privilege 15 password admin //创建一个用户和密码 Switch(config)#ip ssh version 2 //启用ssh版本号 Switch#sh ip ssh //查看自己配置的ssh SSH Enabled - version 2.0 Authentication timeout: 120 secs; Authentication retries: 3 2.2 为交换机配置远程管理IP地址：BOOK#conf t BOOK(config)#int vlan 1 //进入默认vlan 1（把交换机第一口划到vlan1中，连接上层设备） BOOK(config-if)#ip address 192.168.1.1 255.255.255.0 //配置管理地址，即可在客户端用新建的用户及密码SSH登录 2.3 配置交换机名字及enable用户模式密码Switch#configure terminal Switch(config)#hostname BOOK //配置交换机名称 BOOK(config)#enable secret BOOK //配置用户模式密码 Switch(config)#service password-encryption //对所有设置的密码进行加密，可以不配置 2.4 端口及vlan的配置管理 常用show int status查看端口状态:connected、disable、notconnect三种状态 创建和删除vlan （以实际办公网段为准） BOOK#conf t BOOK(config)#vlan 12 //创建12网段 BOOK(config-vlan)#no shutdown //默认创建好就是开启的，这步可以省略 BOOK(config)# no vlan 12 //删除12网段 端口配置 BOOK#conf t BOOK(config)#int fa0/2 //进入端口2 BOOK(config-if)#switchport mode access //把端口设置为access普通端口 BOOK(config-if)#shutdown //端口关闭 BOOK(config-if)#no shutdown //端口打开 BOOK(config-if)#switchport access vlan 12 //把2端口加入12网段 2.5. 开启三层路由及静态路由配置防火墙内网口地址：192.168.1.2 &amp; 交换机默认vlan1管理地址：192.168.1.1 BOOK#conf t BOOK(config)#ip routing //开启三层路由，开启后所有网段互通 BOOK(config)#no ip routing //关闭三层路由 BOOK(config)#ip route 0.0.0.0 0.0.0.0 192.168.1.2 //指向上一层防火墙内网口地址 备注：然后新加的12网段，需要在防火墙上添加一个返程路由即可 Cisco防火墙配置路由 BOOK-office# conf t BOOK-office(config)# route inside 192.168.12.0 255.255.255.0 192.168.1.1 三、实战演练3.1 新增部署网段的步骤BOOK#conf t BOOK(config)#vlan 13 //创建vlan 13 BOOK(config-vlan)#exit //退出到配置模式 BOOK(config)#int vlan 13 // 进入vlan 13 BOOK(config-if)#ip address 192.168.13.1 255.255.255.0 //配置99网段的网关地址 BOOK(config-if)#description bangong-vlan13 //可以对vlan13进行描述，方便后期管理 BOOK(config-if)#exit //退出到配置模式 BOOK(config)#ip dhcp pool 13 //创建99网段的地址池 BOOK(dhcp-config)# network 192.168.13.0 255.255.255.0 //配置网段 BOOK(dhcp-config)# default-router 192.168.13.1 //指定网段的网关 BOOK(dhcp-config)# dns-server 8.8.8.8 202.96.209.5 //配置网段的主和辅DNS BOOK(dhcp-config)# lease 2 //IP地址的租约时间为2天，超过两天没用就会释放 BOOK(config-if)#exit //退出到配置模式 BOOK(config)#ip dhcp excluded-address 192.168.13.1 192.168.13.20 //排除掉的IP地址不分配 BOOK(config)#int range fa0/2 -24 //对2到24端口全局配置 BOOK(config-if-range)#switchport access vlan 13 //全部加入到13网段 3.2 IP和MAC地址绑定 需求：张三想把IP地址192.168.12.80和507b.9dbe.55ea绑定，让客户端只有连接上网络，就会分配这个IP地址，如果更改其它IP则无法上网 思路：首先 12网段的地址池已经有了，客户端如果想获取特定的ip地址，必须先把这个地址从12网段里排除掉，让这个地址不会分配，然后建立一个自己的99网段地址池 步骤如下： BOOK(config)#ip dhcp excluded-address 192.168.12.80 //先把这个IP地址排除不分配 BOOK(config)#ip dhcp pool 12_zhangsan //建立一个张三自己的地址池，名字不能和已有的pool_12重复 BOOK(dhcp-config)# host 192.168.12.80 255.255.255.0 //指定张三的ip地址 BOOK(dhcp-config)# client-identifier 0150.7b9d.be55.ea // MAC地址格式为01xx.xxxx.xxxx.xx BOOK(dhcp-config)# dns-server 8.8.8.8 202.96.209.5 //指定DNS BOOK(dhcp-config)# default-router 192.168.12.1 // 指定网关 BOOK(config)#arp 192.168.12.80 7b.9dbe.55ea ARPA //绑定生效 客户端网卡禁用启用： 3.3 网段访问控制列表 需求：要求办公12网段和财务网段33隔离开，只允许特定的主机可以访问33网段，其它拒绝掉 BOOK# conf t BOOK(config)#ip access-list extended 100 //做一个访问控制列表，编号100 BOOK(config-ext-nacl)#permit ip host 192.168.12.80 any //允许张三这台机器可以访问任何网段 BOOK(config-ext-nacl)#permit ip host 192.168.12.80 host 192.168.33.8 //允许张三访问88.8主机 BOOK(config-ext-nacl)#deny ip any 192.168.22.0 0.0.0.255 //拒绝12网段访问33网段 BOOK(config-ext-nacl)#permit ip any any //允许所有，这条必须加上，否则未放行的无法上网 BOOK(config-ext-nacl)#exit //退出到配置模式 BOOK(config)#int vlan 12 //进入12网段下 BOOK(config-if)#ip access-group 100 in //应用访问控制列表 3.4 常用基本维护命令Show int status 查看端口状态 Show run 查看配置 Show ip dhcp pool 查看全部地址池的使用情况 Show ip dhcp pool vlan 12 只查看12网段的地址池 Show ip dhcp binding 查看租约信息 Show ip dhcp conflict 查看地址冲突信息 Show ip dhcp server statistics 查看DHCP收发数据包统计表 Show ip arp 192.168.12.xx 根据ip地址追踪mac地址 Show mac address-table address 7b.9dbe.55ea根据mac追踪具体端口位置 如果出现网络地址受限，获取不到IP地址，看看是不是地址池满了，重新释放刷新地址池 清除命令： Clear ip dhcp server statist 清除收发数据统计信息 clear ip dhcp binding * 清除所有租约信息 clear mac address-table dynamic 清除动态MAC地址列表 clear arp-cache 清除arp缓存]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cisco asa防火墙配置管理]]></title>
    <url>%2F2019%2F07%2F22%2Fcisco-asa%2F</url>
    <content type="text"><![CDATA[一、配置远程登录 关于怎么用console线连接防火墙,可以参考我上一篇交换机配置博客：https://www.loverbook.cn/2019/07/25/cisco-switch/ Cisco asa 版本8.3之前的命令和之后区别很大，此篇博客以新版本命令为参考，版本太旧建议升级ios 1.1 配置主机名及enable密码 ciscoasa(config)# hostname BOOK-office BOOK-office(config)# enable password xxxxxxx 1.2 配置远程SSH连接BOOK-office(config)# crypto key generate rsa modulus 1024 WARNING: You have a RSA keypair already defined named &lt;Default-RSA-Key&gt;. Do you really want to replace them? [yes/no]: y //输入y回车 BOOK-office(config)# write memory //保存配置 BOOK-office(config)# ssh 0.0.0.0 0.0.0.0 inside //允许内网任何ip可以连接 BOOK-office(config)#ssh timeout 30 //设置超时时间,单位为分钟 BOOK-office(config)# ssh version 2 BOOK-office(config)# username admin password xxxxx //配置远程登录账户 -------------相关命令-------------- show ssh //参看SSH配置信息 show crypto key mypubkey rsa //查看产生的rsa密钥值 crypto key zeroize //清空所有产生的密钥 二、接口配置2.1 内外接口IP配置 外接口 Gi0/0：100.100.100.100(自己公网IP) 内接口 Gi0/1: 192.168.1.1 BOOK-office(config)# int gigabitEthernet 0/0 //把gi0/0配置成外接口 BOOK-office(config-if)# no shutdown //开启端口 BOOK-office(config-if)# security-level 0 BOOK-office(config-if)# nameif outside BOOK-office(config-if)# ip address 100.100.100.100 255.255.255.0 BOOK-office(config)# int gigabitEthernet 0/0 //把gi0/1配置成内接口 BOOK-office(config-if)# no shutdown //开启端口 BOOK-office(config-if)# security-level 100 //流量只允许高往低走 BOOK-office(config-if)# nameif inside BOOK-office(config-if)# ip address 192.168.1.1 255.255.255.0 三、防火墙内外流量打通3.1 NAT转换把内部局域网网段转换流量出去进行上网 BOOK-office(config)#object network inside //定义一个地址对象inside 包含所有内网 BOOK-office(config-network-object)# subnet 0.0.0.0 0.0.0.0 BOOK-office(config-network-object)# nat (inside,outside) dynamic interface //Nat 转换 3.2 访问控制列表----------定义一个 ip-mac的组，允许ip、imcp、tcp、udp协议通过--------- BOOK-office(config)# access-list ip-mac extended permit ip any any BOOK-office(config)# access-list ip-mac extended permit imcp any any BOOK-office(config)# access-list ip-mac extended permit tcp any any BOOK-office(config)# access-list ip-mac extended permit udp any any BOOK-office(config)# access-group ip-mac in interface inside //将这个组应用到内接口上 3.3 添加路由BOOK-office(config)# route outside 0.0.0.0 0.0.0.0 100.100.100.99 1 //出口路由指向出口IP网关 BOOK-office(config)# route inside 192.168.2.0 255.255.255.0 192.168.1.2 1 //内部路由指向下一层连接交换机IP BOOK-office(config)# route inside 192.168.12.0 255.255.255.0 192.168.1.2 1 //新增网段2和网段12返程路由这样防火墙就可以实现内部局域网上网了，可以进行远程连接和上网测试了！！ 四、NAT端口映射4.1 端口映射举例将内网一台测试服务器192.168.12.13的内网3389端口映射到外网的3389端口 BOOK-office(config)#object network testserver //定义一个地址对象 testserver BOOK-office(config-network-object)# host 192.168.12.13 BOOK-office(config-network-object)#nat (inside,outside) static interface service tcp 3389 3389 4.2 访问控制列表及策略应用-------定义控制列表100------- BOOK-office(config)#access-list 100 extended permit tcp any host 192.168.12.13 eq 3389 -------将列表100应用到外接口上生效------ BOOK-office(config)# access-group 100 in interface inside 五、宽带拨号（可选）5.1 宽带PPOE拨号 应用场景：没有固定IP地址，防火墙连接防火墙直接自身拨号，可以用此方法配置 -------配置宽带账号和密码------- BOOK-office(config)# vpdn group ads1 request dialout pppoe BOOK-office(config)# vpdn group ads1 localname adxxxxx //此处填写宽带账户 BOOK-office(config)# vpdn group ads1 ppp authentication pap BOOK-office(config)# vpdn username adxxxxx password xxxxxxx //宽带账户和密码 -------把拨号方式应用到外接口上，替代之前的固定IP地址------- BOOK-office(config)# int gigabitEthernet 0/0 BOOK-office(config-if)# pppoe client vpdn group ads1 BOOK-office(config-if)# ip address pppoe setroute]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Openvpn服务器搭建]]></title>
    <url>%2F2019%2F05%2F20%2FOpenvpnserver%2F</url>
    <content type="text"><![CDATA[一、前言OpenVPN 是一个基于 OpenSSL 库的应用层 VPN 实现，和传统 VPN 相比，它的优点是简单易用、安全稳定。此次基于centos7.3系统编译安装，使用udp协议自定义端口，搭建的目的是为了能实现通过证书+账户密码双重认证的方法，登录到阿里云VPC内部，对服务器进行配置管理。 准备工具 Easy-rsa.zip //秘钥制作工具 Lzo-2.0.6.tar.gz //依赖包 Openvpn-2.3.3.tar.gz //安装包 网段 openvpn主机ip : 172.xx.xx.xx 外网ip: 100.100.100.100 vpn网段：20.8.8.0 二、安装Openvpn2.1 安装依赖包pam-devel是安装openvpn必要的依赖包 [root@test ~]# yum -y install unzip ntpdate pam-devel openssl openssl-devel 2.2 上传包文件通过ssh连接上openvpn服务器，把3个文件拷贝到/usr/local/目录下，并分别解压 [root@test local]# unzip easy-rsa.zip #asy-rsa证书制作工具 [root@test local]# tar -zxvf lzo-2.06.tar.gz #lzo-2.0.6.tar.gz依赖包 [root@test local]# tar -zxvf openvpn-2.3.3.tar.gz 2.3 创建安装目录[root@test local]# mkdir -p /usr/local/openvpn/conf #于存放配置文件 [root@test local]# mkdir –p /usr/local/openvpn/log #于存放日志文件 [root@test local]# mkdir -p /usr/local/openvpn/easy-rsa #密钥生成工具及密钥 2.4 开始安装openvpn进入/usr/local/目录下: [root@test local]# cd lzo-2.06 [root@test lzo-2.06]# ./configure --prefix=/usr #装依赖库 [root@test lzo-2.06]#make &amp;&amp; make install [root@test lzo-2.06]# /sbin/ldconfig #置运行时动态链接库 [root@test local]# cd openvpn-2.3.3 [root@test openvpn-2.3.3]# ./configure --prefix=/usr/local/openvpn/ [root@test openvpn-2.3.3]# make &amp;&amp; make install [root@testopenvpn-2.3.3]#cd sample/sample-config-files/ [root@test sample-config-files]# cp server.conf /usr/local/openvpn/conf/ #贝配置文件 [root@test local]# cd easy-rsa/2.0/ [root@test 2.0]# cp -rf * /usr/local/openvpn/easy-rsa/ [root@test 2.0]# cd /usr/local/openvpn/easy-rsa/ [root@test easy-rsa]# chmod +x * 三、配置openvpn3.1 配置Vars文件及生成服务端证书[root@test ~]# cd /usr/local/openvpn/easy-rsa/ [root@test easy-rsa]# vim vars #配置vars文件（证书的默认配置） export KEY_SIZE=2048 #加密位数，太大增加CPU负载 export CA_EXPIRE=3650 #证书有效期，这里是10年 export KEY_EXPIRE=365 #秘钥有效期 export KEY_COUNTRY=&quot;CN&quot; #国家 export KEY_PROVINCE=&quot;SH&quot; #省份 export KEY_CITY=&quot;Shanghai&quot; #所在城市 export KEY_ORG=&quot;yunwei&quot; # 组织单位 export KEY_EMAIL=&quot;yunwei@book.cn&quot; #邮箱地址 export KEY_OU=&quot;Yunwei&quot; #组织容器可以随便填写 export KEY_NAME=&quot;VPNServer&quot; #名称可以随便填写 [root@test easy-rsa]# source vars #使配置生效 下面开始制作根证书CA: [root@test easy-rsa]# ./clean-all #初始化 [root@test easy-rsa]# ./build-ca #创建根证书，一路回车 Generating a 2048 bit RSA private key ..................................+++ ...............................+++ writing new private key to &#39;ca.key&#39; ----- You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter &#39;.&#39;, the field will be left blank. ----- Country Name (2 letter code) [CN]: State or Province Name (full name) [SH]: Locality Name (eg, city) [Shanghai]: Organization Name (eg, company) [yunwei]: Organizational Unit Name (eg, section) [Yunwei]: Common Name (eg, your name or your server&#39;s hostname) [yunwei CA]: Name [EasyServer]: Email Address [yunwei@book.cn]: 创建服务器端证书server和秘钥: [root@test easy-rsa]# ./build-key-server server #一路回车默认，最后输入y确认 Generating a 2048 bit RSA private key ...........+++ ....+++ writing new private key to &#39;server.key&#39; ----- You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter &#39;.&#39;, the field will be left blank. ----- Country Name (2 letter code) [CN]: State or Province Name (full name) [SH]: Locality Name (eg, city) [Shanghai]: Organization Name (eg, company) [yunwei]: Organizational Unit Name (eg, section) [Yunwei]: Common Name (eg, your name or your server&#39;s hostname) [server]: Name [EasyServer]: Email Address [yunwei@book.cn]: Please enter the following &#39;extra&#39; attributes to be sent with your certificate request A challenge password []: An optional company name []: Using configuration from /usr/local/openvpn/easy-rsa/openssl-1.0.0.cnf Check that the request matches the signature Signature ok The Subject&#39;s Distinguished Name is as follows countryName :PRINTABLE:&#39;CN&#39; stateOrProvinceName :PRINTABLE:&#39;SH&#39; localityName :PRINTABLE:&#39;Shanghai&#39; organizationName :PRINTABLE:&#39;yunwei&#39; organizationalUnitName:PRINTABLE:&#39;Yunwei&#39; commonName :PRINTABLE:&#39;server&#39; name :PRINTABLE:&#39;EasyServer&#39; emailAddress :IA5STRING:&#39;yunwei@book.cn&#39; Certificate is to be certified until Apr 15 15:35:32 2019 GMT (365 days) Sign the certificate? [y/n]:y #输入y 1 out of 1 certificate requests certified, commit? [y/n] y #输入y Write out database with 1 new entries [root@test easy-rsa]# ./build-dh #创建dh2048加密协商文件 [root@test easy-rsa]# [root@testeasy-rsa]#../sbin/openvpn --genkey --secret /usr/local/openvpn/easy-rsa/keys/ta.key #生成防Dos攻击的文件 3.2 配置openvpn server文件[root@test ~]# vim /usr/local/openvpn/conf/server.conf Local 172.xx.xx.xx #本机监听地址 port 2294 #自定义端口号 proto udp #使用udp协议 dev tun #tun是ip层的点对点协议,建议使用tun #证书若没放在conf下，需要指定路径 ca /usr/local/openvpn/easy-rsa/keys/ca.crt cert /usr/local/openvpn/easy-rsa/keys/server.crt key /usr/local/openvpn/easy-rsa/keys/server.key # This file should be kept secret dh /usr/local/openvpn/easy-rsa/keys/dh2048.pem server 20.8.8.0 255.255.255.0 #服务器vpn网段地址 #防止openvpn重新启动后“忘记”Client曾经使用过的IP地址 ifconfig-pool-persist /usr/local/openvpn/log/ipp.txt #通过VPN Server往Client push路由，client通过pull指令获得 push &quot;route 20.8.8.0 255.255.255.0&quot; push &quot;route 172.xx.xx.0 255.255.255.0&quot; push &quot;dhcp-option DNS 223.5.5.5&quot; #指定DNS地址 push &quot;dhcp-option DNS 8.8.8.8&quot; client-to-client #和keys连接VPN，一定要打开这个选项，否则只允许一个人连接VPN duplicate-cn keepalive 10 120 comp-lzo #对数据进行压缩 max-clients 10 #支持客户端数 通过keepalive检测超时后，重新启动VPN，不重新读取keys，保留第一次使用的keys persist-key #通过keepalive检测超时后，重新启动VPN，一直保持tun或者tap设备是linkup的，否则网络连接会先linkdown然后linkup persist-tun status /usr/local/openvpn/log/openvpn-status.log #日志路径 log-append /usr/local/openvpn/log/openvpn.log verb 3 四、用户密码+证书验证配置4.1 创建客户端用户[root@test ~]# cd /usr/local/openvpn/easy-rsa/ [root@test easy-rsa]# ./build-key book #创建用户book，方法同server端备注：执行后会在keys文件夹下，生成3个文件，book.crt、book.csr（mac电脑不需要这个文件）、book.key，另外加上同目录下的ca.crt、ca.key、ta.key和dh2048.pem这7个文件一起打包，即是客户端所需要的所有文件，添加其它用户也是同样的方法 4.2 配置账户密码验证[root@test ~]# vi /usr/local/openvpn/conf/server.conf #配置文件中加上以下几行 tls-auth /usr/local/openvpn/easy-rsa/keys/ta.key 0 #server端是0 ,客户端为1 auth-user-pass-verify /usr/local/openvpn/easy-rsa/checkpsw.sh via-env #密码验证的脚本文件放在此目录下，稍后创建脚本 script-security 3 username-as-common-name ;client-cert-not-required #如果只想账户密码验证，就开启这句创建脚本文件：checkpsw.sh #!/bin/sh ########################################################### # checkpsw.sh (C) 2004 Mathias Sundman &lt;mathias@openvpn.se&gt; # # This script will authenticate OpenVPN users against # a plain text file. The passfile should simply contain # one row per user with the username first followed by # one or more space(s) or tab(s) and then the password. PASSFILE=&quot;/usr/local/openvpn/easy-rsa/psw-file&quot; //指定保存账户和密码的文件 LOG_FILE=&quot;/usr/local/openvpn/log/openvpn-password.log&quot;//保存日志文件 TIME_STAMP=`date &quot;+%Y-%m-%d %T&quot;` ########################################################### if [ ! -r &quot;${PASSFILE}&quot; ]; then echo &quot;${TIME_STAMP}: Could not open password file \&quot;${PASSFILE}\&quot; for reading.&quot; &gt;&gt; ${LOG_FILE} exit 1 fi CORRECT_PASSWORD=`awk &#39;!/^;/&amp;&amp;!/^#/&amp;&amp;$1==&quot;&#39;${username}&#39;&quot;{print $2;exit}&#39; ${PASSFILE}` if [ &quot;${CORRECT_PASSWORD}&quot; = &quot;&quot; ]; then echo &quot;${TIME_STAMP}: User does not exist: username=\&quot;${username}\&quot;, password=\&quot;${password}\&quot;.&quot; &gt;&gt; ${LOG_FILE} exit 1 fi if [ &quot;${password}&quot; = &quot;${CORRECT_PASSWORD}&quot; ]; then echo &quot;${TIME_STAMP}: Successful authentication: username=\&quot;${username}\&quot;.&quot; &gt;&gt; ${LOG_FILE} exit 0 fi echo &quot;${TIME_STAMP}: Incorrect password: username=\&quot;${username}\&quot;, password=\&quot;${password}\&quot;.&quot; &gt;&gt; ${LOG_FILE} exit 1创建保存账户密码的文件： psw-file [root@test easy-rsa]#vi psw-file book 123456 //账户+空格+密码格式保存 4.3 注销用户客户端如果同事离职了，需要注销证书 [root@test easy-rsa]# ./revoke-full book //注销用户book 这个时候还是可以利用此证书登录服务器的，在server.conf下增加一行 crl-verify /usr/local/openvpn/easy-rsa/keys/crl.pem 再重启下openvpn服务即可 4.4 启动openvpn[root@test~]# /usr/local/openvpn/sbin/openvpn --config /usr/local/openvpn/conf/server.conf &amp; [root@test~]#ps –ef |grep openvpn root 1013 1 0 Apr13 ? 00:00:04 /usr/local/openvpn/sbin/openvpn --config /usr/local/openvpn/conf/server.conf [root@test~]# netstat -ntlup //由此可见端口已在监听 Udp 0 0 172.xx.xx.xx:2294 0.0.0.0:* 1013/openvpn 五、配置防火墙5.1 开启路由转发[root@test ~]# vim /etc/sysctl.conf net.ipv4.ip_forward = 1 #将值改为1保存 [root@test ~]# sysctl -p #执行生效 5.2 配置iptables NAT转发[root@test ~]# systemctl stop firewalld.service [root@test ~]# systemctl disable firewalld.service [root@test ~]# yum install -y iptables-services [root@test ~]# systemctl enable iptables [root@test ~]# iptables -F #清空iptables配置规则 [root@test ~]# iptables -X [root@test ~]# iptables -P OUTPUT ACCEPT [root@test ~]# iptables -P FORWARD ACCEPT [root@test ~]# iptables -A INPUT -i lo -j ACCEPT [root@test ~]# iptables -A OUTPUT -o lo -j ACCEPT [root@test ~]#iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT [root@test ~]# iptables -A INPUT -p tcp --dport 22 -j ACCEPT [root@test ~]# iptables -A INPUT -p udp --dport 2294 -j ACCEPT #对vpn网段进行转发 [root@test ~]# iptables -t nat -A POSTROUTING -o eth0 -s 20.8.8.0/24 -j MASQUERADE #把内部主机端口的流量指定到出口ip [root@test ~]# iptables -t nat -A PREROUTING -s 100.100.100.100 -p udp -m udp --dport 2294 -j DNAT --to-destination 172.xx.xx.xx:2294 [root@test ~]#service iptables save [root@test ~]#service iptables restart 六、客户端配置文件 打开client.ovpn配置文件 Client dev tun proto udp remote 100.100.100.100 2294 resolv-retry infinite nobind persist-key persist-tun ca ca.crt cert book.crt #这里是指定用户证书，名字要和拷贝过来的文件一致 key book.key ns-cert-type server comp-lzo verb 3 tls-auth ta.key 1 #这里客户端为1 auth-user-pass #这里要加上，用户密码验证]]></content>
      <categories>
        <category>linux 运维</category>
      </categories>
      <tags>
        <tag>linux 运维</tag>
      </tags>
  </entry>
</search>
